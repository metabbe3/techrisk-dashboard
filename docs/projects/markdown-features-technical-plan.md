# Markdown Features Technical Plan
## Incident Report Export & Document Conversion

**Project:** PROJ-003 & PROJ-004
**Status:** Planning
**Created:** 2026-02-02
**Priority:** P2

---

## Executive Summary

This document outlines the technical architecture and implementation plan for two related Markdown features:

1. **Feature 1 (PROJ-003):** Export Incident Reports to Markdown
2. **Feature 2 (PROJ-004):** Convert Uploaded Documents to Markdown

Both features share common infrastructure and should be implemented together to maximize code reuse and maintainability.

---

## Architecture Overview

### Shared Components

```
app/
├── Services/
│   ├── Markdown/
│   │   ├── MarkdownExportService.php          # Shared base service
│   │   ├── IncidentMarkdownExporter.php       # Feature 1: Export incidents
│   │   ├── DocumentConverterService.php        # Feature 2: Convert uploaded docs
│   │   └── MarkdownFormatter.php              # Shared formatting utilities
│   └── EncryptionService.php                  # Existing service
├── Jobs/
│   └── ConvertDocumentToMarkdown.php          # Queue job for async conversion
└── Models/
    ├── InvestigationDocument.php              # Extended with markdown support
    └── Incident.php                            # Extended with export methods
```

### Storage Strategy

```
storage/
├── app/
│   ├── markdown/
│   │   ├── incidents/                         # Exported incident reports
│   │   │   └── {incident_id}.md
│   │   └── documents/                         # Converted uploaded documents
│   │       └── {document_id}.md
└── public/
    └── investigation-forms/                   # Existing encrypted storage
```

---

## Feature 1: Export Incident Reports to Markdown

### Requirements

- Export individual incident reports to well-structured Markdown format
- Accessible from incident view page (Filament)
- Include all incident data and relationships
- AI-consumable structure (semantic HTML, consistent formatting)

### Data Structure to Export

```markdown
# Incident Report: {no} - {title}

## Metadata
- **Incident ID:** {id}
- **Incident Number:** {no}
- **Type:** {incident_type.name}
- **Classification:** {classification}
- **Severity:** {severity}
- **Status:** {latestStatusUpdate.status}
- **Incident Date:** {incident_date}
- **Entry Date:** {entry_date_tech_risk}

## Summary
{summary}

## Root Cause
{root_cause}

## Timeline and Chronology
{timeline}

## Impact & Triage
### Financial Impact
- **Potential Fund Loss:** {potential_fund_loss}
- **Actual Fund Loss:** {fund_loss}
- **Recovered Fund:** {recovered_fund}
- **Loss Taken By:** {loss_taken_by}

### Timeline Metrics
- **Discovered At:** {discovered_at}
- **Stop Bleeding At:** {stop_bleeding_at}
- **MTTR:** {mttr} minutes
- **MTBF:** {mtbf} days

### People & Assignments
- **PIC:** {pic.name}
- **Reported By:** {reported_by}
- **People Caused:** {people_caused}
- **Checker:** {checker}
- **Maker:** {maker}

### Third Party Involvement
{third_party_client}

## Status Updates
### {status_1.status} - {status_1.created_at}
{status_1.notes}

[... more status updates]

## Action Items & Improvements
### [{action_improvement_1.status}] {action_improvement_1.title}
**Assigned to:** {action_improvement_1.pic}
**Target Date:** {action_improvement_1.target_date}
{action_improvement_1.description}

[... more action items]

## Supporting Documents
### {document_1.description}
- **Original Filename:** {document_1.original_filename}
- **PIC & Status:** {document_1.pic_status}
- **Uploaded:** {document_1.created_at}

[... more documents]

## Labels
{label_1.name}, {label_2.name}, ...

## Audit Trail
[Optionally include audit history]

---
*Generated by Technical Risk Dashboard on {generated_at}*
```

### Implementation Components

#### 1. IncidentMarkdownExporter Service

```php
namespace App\Services\Markdown;

use App\Models\Incident;
use Illuminate\Support\Facades\Storage;

class IncidentMarkdownExporter
{
    public function export(Incident $incident): string
    {
        $markdown = view('markdown.incident', [
            'incident' => $incident->load([
                'incidentType',
                'latestStatusUpdate',
                'pic',
                'statusUpdates',
                'actionImprovements',
                'investigationDocuments',
                'labels'
            ])
        ])->render();

        return $markdown;
    }

    public function exportToFile(Incident $incident, string $path = null): string
    {
        $markdown = $this->export($incident);
        $filename = $path ?? "markdown/incidents/{$incident->id}.md";

        Storage::disk('local')->put($filename, $markdown);

        return $filename;
    }

    public function download(Incident $incident): \Symfony\Component\HttpFoundation\StreamedResponse
    {
        $markdown = $this->export($incident);
        $filename = "incident-{$incident->no}-{$incident->id}.md";

        return response()->streamDownload(
            fn() => echo $markdown,
            $filename,
            ['Content-Type' => 'text/markdown']
        );
    }
}
```

#### 2. Blade Template

```php
{{-- resources/views/markdown/incident.blade.php --}}
# Incident Report: {{ $incident->no }} - {{ $incident->title }}

## Metadata
- **Incident ID:** {{ $incident->id }}
- **Incident Number:** {{ $incident->no }}
@if($incident->incidentType)
- **Type:** {{ $incident->incidentType->name }}
@endif
- **Classification:** {{ $incident->classification }}
- **Severity:** {{ $incident->severity }}
- **Status:** {{ $incident->latestStatusUpdate?->status ?? 'N/A' }}
- **Incident Date:** {{ $incident->incident_date?->format('Y-m-d H:i:s') }}
- **Entry Date:** {{ $incident->entry_date_tech_risk?->format('Y-m-d') }}

## Summary
{{ $incident->summary }}

## Root Cause
{{ $incident->root_cause }}

## Timeline and Chronology
{{ $incident->timeline }}

[... continue with full structure ...]
```

#### 3. Filament Action (ViewIncident.php)

```php
use Filament\Actions\Action;
use App\Services\Markdown\IncidentMarkdownExporter;

protected function getHeaderActions(): array
{
    return [
        // ... existing actions
        Action::make('export_markdown')
            ->label('Export to Markdown')
            ->icon('heroicon-o-document-arrow-down')
            ->color('success')
            ->action(function (IncidentMarkdownExporter $exporter) {
                return $exporter->download($this->record);
            }),
    ];
}
```

---

## Feature 2: Convert Uploaded Documents to Markdown

### Requirements

- Automatically convert uploaded PDF/DOC files to Markdown
- Store converted markdown for AI consumption
- Support PDF and DOCX formats
- Queue conversion for performance
- Handle encrypted files

### Recommended Packages

Based on research, here are the best options:

#### Option 1: Hybrid Approach (RECOMMENDED)

**For PDF to Markdown:**
- **Package:** `iamgerwin/php-pdf-to-markdown-parser`
- **Pros:**
  - Dedicated PDF to Markdown conversion
  - Lightweight and focused
  - Supports text extraction, headings, lists, tables
  - Recently updated (September 2025)
- **Cons:**
  - Newer package, less battle-tested
  - May have limited image handling

**For DOCX to Markdown:**
- **Package:** `phpoffice/phpword` + custom conversion
- **Pros:**
  - Well-established, actively maintained
  - Robust DOCX parsing
  - Good documentation
  - Large community
- **Cons:**
  - Doesn't natively output Markdown (requires custom conversion logic)
  - More complex setup

**Composer dependencies:**
```json
{
    "require": {
        "iamgerwin/php-pdf-to-markdown-parser": "^1.0",
        "phpoffice/phpword": "^1.0"
    }
}
```

#### Option 2: LibreOffice via Doxswap

**Package:** Doxswap (via [Laravel News article](https://laravel-news.com/seamless-document-conversion-in-laravel-with-docswap))

**Pros:**
- Single solution for both PDF and DOCX
- Leverages LibreOffice (mature, battle-tested)
- Supports many formats
- Featured in Laravel community (March 2025)

**Cons:**
- Requires LibreOffice installation on server
- May be slower (spawns external process)
- Server dependency increases deployment complexity
- Conversion quality may vary

**Not recommended** for this use case due to server dependency and async processing complexity.

#### Option 3: Pandoc Integration

**Approach:** Use Pandoc CLI tool via Laravel's `Process` facade

**Pros:**
- Most comprehensive conversion support
- Battle-tested, industry standard
- Excellent format preservation
- Active development

**Cons:**
- Requires Pandoc installation on server
- External process dependency
- Security considerations (shell escaping)
- Async queue management complexity

**Viable alternative** if LibreOffice is already available in infrastructure.

### Implementation Design (Using Option 1 - Hybrid)

#### 1. Database Migration

```php
// Add markdown_path to investigation_documents
Schema::table('investigation_documents', function (Blueprint $table) {
    $table->string('markdown_path')->nullable();
    $table->timestamp('markdown_converted_at')->nullable();
    $table->string('markdown_conversion_status')->default('pending');
    // Values: pending, processing, completed, failed
});
```

#### 2. DocumentConverterService

```php
namespace App\Services\Markdown;

use App\Models\InvestigationDocument;
use App\Services\EncryptionService;
use Illuminate\Support\Facades\Storage;
use PhpOffice\PhpWord\PhpWord;
use Iamgerwin\PdfToMarkdown\PdfParser;

class DocumentConverterService
{
    public function __construct(
        private EncryptionService $encryption
    ) {}

    public function convert(InvestigationDocument $document): ?string
    {
        if (!$this->shouldConvert($document)) {
            return null;
        }

        $this->updateStatus($document, 'processing');

        try {
            // Decrypt the file
            $content = $this->getDecryptedContent($document);

            // Convert based on file type
            $markdown = $this->convertContent(
                $content,
                $document->original_filename
            );

            // Store markdown
            $path = $this->storeMarkdown($document, $markdown);

            // Update document record
            $document->update([
                'markdown_path' => $path,
                'markdown_converted_at' => now(),
                'markdown_conversion_status' => 'completed'
            ]);

            return $markdown;
        } catch (\Exception $e) {
            $document->update([
                'markdown_conversion_status' => 'failed'
            ]);
            throw $e;
        }
    }

    private function shouldConvert(InvestigationDocument $document): bool
    {
        $extension = strtolower(pathinfo($document->original_filename, PATHINFO_EXTENSION));
        return in_array($extension, ['pdf', 'docx', 'doc']);
    }

    private function getDecryptedContent(InvestigationDocument $document): string
    {
        $encryptionKey = $document->encryptionKey;
        if (!$encryptionKey) {
            throw new \Exception('No encryption key found');
        }

        $encryptedContent = Storage::disk('public')->get($document->file_path);
        $finalKey = $this->encryption->getFinalKey(
            $encryptionKey->key,
            $encryptionKey->salt,
            $encryptionKey->method
        );

        return $this->encryption->decrypt($encryptedContent, $finalKey);
    }

    private function convertContent(string $content, string $filename): string
    {
        $extension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));

        return match($extension) {
            'pdf' => $this->convertPdf($content),
            'docx', 'doc' => $this->convertDocx($content),
            default => throw new \Exception("Unsupported file type: {$extension}")
        };
    }

    private function convertPdf(string $content): string
    {
        // Save temporary file
        $tempPath = storage_path('app/temp/' . uniqid() . '.pdf');
        file_put_contents($tempPath, $content);

        try {
            $parser = new PdfParser();
            $markdown = $parser->parse($tempPath);
            return $markdown->toMarkdown();
        } finally {
            unlink($tempPath);
        }
    }

    private function convertDocx(string $content): string
    {
        // Save temporary file
        $tempPath = storage_path('app/temp/' . uniqid() . '.docx');
        file_put_contents($tempPath, $content);

        try {
            $phpWord = PhpWord::load($tempPath);
            return $this->phpWordToMarkdown($phpWord);
        } finally {
            unlink($tempPath);
        }
    }

    private function phpWordToMarkdown(PhpWord $phpWord): string
    {
        $markdown = '';

        foreach ($phpWord->getSections() as $section) {
            foreach ($section->getElements() as $element) {
                $markdown .= $this->convertElement($element);
            }
        }

        return $markdown;
    }

    private function convertElement($element): string
    {
        // Handle different element types (text, headings, lists, tables)
        if (method_exists($element, 'getText')) {
            return $element->getText() . "\n\n";
        }

        // Add more element type handlers...
        return '';
    }

    private function storeMarkdown(
        InvestigationDocument $document,
        string $markdown
    ): string {
        $filename = "markdown/documents/{$document->id}.md";
        Storage::disk('local')->put($filename, $markdown);
        return $filename;
    }

    private function updateStatus(
        InvestigationDocument $document,
        string $status
    ): void {
        $document->update([
            'markdown_conversion_status' => $status
        ]);
    }
}
```

#### 3. Queue Job

```php
namespace App\Jobs;

use App\Models\InvestigationDocument;
use App\Services\Markdown\DocumentConverterService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class ConvertDocumentToMarkdown implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $tries = 3;
    public $backoff = [60, 300, 900]; // 1min, 5min, 15min

    public function __construct(
        public InvestigationDocument $document
    ) {}

    public function handle(DocumentConverterService $converter): void
    {
        try {
            $converter->convert($this->document);
            Log::info("Document converted to markdown", [
                'document_id' => $this->document->id
            ]);
        } catch (\Exception $e) {
            Log::error("Failed to convert document to markdown", [
                'document_id' => $this->document->id,
                'error' => $e->getMessage()
            ]);
            throw $e;
        }
    }

    public function failed(\Throwable $exception): void
    {
        $this->document->update([
            'markdown_conversion_status' => 'failed'
        ]);
    }
}
```

#### 4. Integration with Upload (InvestigationDocumentsRelationManager)

```php
// In after() callback of CreateAction
->after(function (Model $record) {
    // ... existing encryption code ...

    // Dispatch markdown conversion job
    \App\Jobs\ConvertDocumentToMarkdown::dispatch($record);

    Notification::make()
        ->title('Document uploaded and queued for conversion')
        ->success()
        ->send();
})
```

#### 5. Filament Actions

```php
// Add to table actions
Tables\Actions\Action::make('view_markdown')
    ->icon('heroicon-o-document-text')
    ->label('View Markdown')
    ->visible(fn($record) => $record->markdown_path !== null)
    ->modalContent(fn($record) => view('filament.modals.document-markdown', [
        'markdown' => Storage::disk('local')->get($record->markdown_path)
    ])),

Tables\Actions\Action::make('download_markdown')
    ->icon('heroicon-o-arrow-down-tray')
    ->label('Download Markdown')
    ->visible(fn($record) => $record->markdown_path !== null)
    ->action(function ($record) {
        return response()->streamDownload(
            fn() => echo Storage::disk('local')->get($record->markdown_path),
            pathinfo($record->original_filename, PATHINFO_FILENAME) . '.md',
            ['Content-Type' => 'text/markdown']
        );
    }),

Tables\Actions\Action::make('reconvert')
    ->icon('heroicon-o-arrow-path')
    ->label('Reconvert to Markdown')
    ->color('warning')
    ->action(function ($record) {
        $record->update(['markdown_conversion_status' => 'pending']);
        \App\Jobs\ConvertDocumentToMarkdown::dispatch($record);
        Notification::make()
            ->title('Document requeued for conversion')
            ->success()
            ->send();
    }),
```

---

## Shared Components

### MarkdownFormatter Utility

```php
namespace App\Services\Markdown;

class MarkdownFormatter
{
    public static function clean(string $text): string
    {
        // Remove excessive whitespace
        $text = preg_replace('/\s{2,}/', ' ', $text);

        // Clean up special characters
        $text = str_replace(["\r\n", "\r"], "\n", $text);

        return trim($text);
    }

    public static function escape(string $text): string
    {
        // Escape markdown special characters when needed
        $chars = ['\\', '`', '*', '_', '{', '}', '[', ']',
                  '(', ')', '#', '+', '-', '.', '!', '|'];

        return str_replace($chars, function($char) {
            return '\\' . $char;
        }, $text);
    }

    public static function formatMoney(float $amount, string $currency = 'IDR'): string
    {
        return number_format($amount, 0, ',', '.') . ' ' . $currency;
    }

    public static function formatDate(\DateTime $date): string
    {
        return $date->format('Y-m-d H:i:s T');
    }
}
```

---

## Implementation Tasks

### Phase 1: Foundation (Feature 1 - Incident Export)
- [ ] Task 1.1: Create MarkdownExportService base class
- [ ] Task 1.2: Create IncidentMarkdownExporter service
- [ ] Task 1.3: Create resources/views/markdown/incident.blade.php template
- [ ] Task 1.4: Add export_markdown action to ViewIncident page
- [ ] Task 1.5: Create tests for markdown export format
- [ ] Task 1.6: Manual testing with various incident data
- [ ] Task 1.7: Documentation update

**Estimated Time:** 3-4 days
**Complexity:** Low-Medium
**Dependencies:** None

### Phase 2: Document Conversion (Feature 2)
- [ ] Task 2.1: Create database migration for markdown fields
- [ ] Task 2.2: Install composer packages (iamgerwin/php-pdf-to-markdown-parser, phpoffice/phpword)
- [ ] Task 2.3: Create DocumentConverterService
- [ ] Task 2.4: Create ConvertDocumentToMarkdown queue job
- [ ] Task 2.5: Update InvestigationDocumentsRelationManager to dispatch job
- [ ] Task 2.6: Create Filament actions for viewing/downloading markdown
- [ ] Task 2.7: Create temp storage directory and configure cleanup
- [ ] Task 2.8: Create tests for conversion service
- [ ] Task 2.9: Manual testing with PDF and DOCX files
- [ ] Task 2.10: Error handling and retry logic testing

**Estimated Time:** 5-7 days
**Complexity:** Medium-High
**Dependencies:** None (can start in parallel with Phase 1)

### Phase 3: Integration & Polish
- [ ] Task 3.1: Add markdown search capability (future enhancement)
- [ ] Task 3.2: Performance testing with large documents
- [ ] Task 3.3: Add queue monitoring and failure notifications
- [ ] Task 3.4: Update documentation
- [ ] Task 3.5: Code review and refinement

**Estimated Time:** 2-3 days
**Complexity:** Low
**Dependencies:** Phase 1 & 2 complete

---

## Risk Assessment

### Technical Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| PDF/DOCX conversion quality issues | High | Medium | Implement manual review process, provide reconvert option |
| Performance issues with large files | Medium | Medium | Queue processing, add file size limits, monitor queue |
| Package compatibility issues | Medium | Low | Thorough testing, check package maintenance status |
| Memory issues with large PDFs | High | Low | Implement streaming, add memory limits, use queues |
| Encryption overhead in conversion | Medium | Low | Cache decrypted content temporarily during conversion |
| Temporary file cleanup failures | Low | Medium | Implement scheduled cleanup, error handling |

### Operational Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Queue failures causing backlog | Medium | Medium | Monitor queue depth, add scaling alerts |
| Storage growth from markdown files | Low | High | Monitor storage usage, implement cleanup policies |
| Server resource exhaustion during conversion | Medium | Low | Limit concurrent jobs, add timeouts |
| Security issues with file parsing | High | Low | Validate file types, sandbox if needed, sanitize output |

---

## Testing Strategy

### Unit Tests

1. **IncidentMarkdownExporterTest**
   - Test markdown generation with various incident data
   - Test relationship loading
   - Test file storage
   - Test download response

2. **DocumentConverterServiceTest**
   - Test PDF conversion
   - Test DOCX conversion
   - Test error handling
   - Test status updates

3. **MarkdownFormatterTest**
   - Test text cleaning
   - Test character escaping
   - Test date/money formatting

### Integration Tests

1. **End-to-end incident export**
2. **Document upload and conversion flow**
3. **Queue job processing**
4. **Filament action responses**

### Manual Testing

1. Test with real incident data
2. Test with various PDF types (scanned, text-based, images)
3. Test with various DOCX types (formatting, tables, images)
4. Test with large files (>10MB)
5. Test queue failures and retries
6. Test encryption/decryption during conversion

---

## Performance Considerations

1. **Queue Configuration**
   - Use dedicated queue for document conversion
   - Set reasonable timeouts (5-10 minutes per job)
   - Implement retry logic with exponential backoff

2. **Memory Management**
   - Set memory_limit in queue workers
   - Use streaming for large files
   - Clean up temporary files immediately

3. **Storage**
   - Monitor markdown storage growth
   - Implement cleanup for deleted documents
   - Consider compression for old markdown files

4. **Caching**
   - Cache converted markdown
   - Implement cache invalidation on document update

---

## Security Considerations

1. **File Validation**
   - Validate file types before conversion
   - Check file signatures (magic numbers)
   - Limit file sizes

2. **Sanitization**
   - Sanitize converted markdown to remove XSS risks
   - Remove or escape dangerous content

3. **Access Control**
   - Ensure only authorized users can access markdown
   - Apply same permissions as original documents

4. **Temporary Files**
   - Store outside web root
   - Use random filenames
   - Clean up promptly

---

## Monitoring & Observability

1. **Metrics to Track**
   - Conversion success rate
   - Average conversion time
   - Queue depth and processing time
   - Storage usage
   - Error rates by file type

2. **Logging**
   - Log all conversion attempts
   - Log errors with full context
   - Log performance metrics

3. **Alerts**
   - High conversion failure rate
   - Queue backlog
   - Storage threshold exceeded

---

## Future Enhancements

1. **Search Integration**
   - Full-text search across converted markdown
   - Integrate with incident search

2. **AI Analysis**
   - Send converted documents to AI for analysis
   - Extract insights from incident patterns

3. **Batch Export**
   - Export multiple incidents at once
   - Create incident summary reports

4. **Version History**
   - Track markdown version changes
   - Compare document versions

5. **Advanced Formatting**
   - Preserve images from documents
   - Better table formatting
   - Handle complex document structures

---

## Sources

### PDF to Markdown Research
- [iamgerwin/php-pdf-to-markdown-parser](https://packagist.org/packages/iamgerwin/php-pdf-to-markdown-parser) - Dedicated PDF to Markdown library (September 2025)
- [jumbaeric/Laravel_Docverter](https://github.com/jumbaeric/Laravel_Docverter) - Multi-format Laravel conversion package
- [How to Convert PDF to Markdown: Complete Guide for 2025](https://blazedocs.io/blog/how-to-convert-pdf-to-markdown) - General conversion guide

### DOCX to Markdown Research
- [Seamless Document Conversion in Laravel With Docswap](https://laravel-news.com/seamless-document-conversion-in-laravel-with-docswap) - Doxswap package (March 2025)
- [A Laravel package for docs conversion using LibreOffice](https://www.amitmerchant.com/laravel-package-for-docs-conversion-using-libreoffice/) - LibreOffice approach
- [Best Markdown libraries for PHP](https://php.watch/articles/php-markdown-libraries) - PHP Markdown ecosystem overview

---

## Conclusion

The recommended approach uses a hybrid solution:

1. **Incident Export:** Custom service with Blade templates (Feature 1)
2. **Document Conversion:**
   - `iamgerwin/php-pdf-to-markdown-parser` for PDF
   - `phpoffice/phpword` for DOCX

This provides the best balance of:
- No external server dependencies
- Laravel-native integration
- Active package maintenance
- Good conversion quality
- Reasonable complexity

Both features share common infrastructure and should be developed together to maximize code reuse.

**Total Estimated Timeline:** 10-14 days
**Recommended Team:** 1 Backend Developer, 1 Frontend Developer (part-time)
**Risk Level:** Medium (mitigated by thorough testing and monitoring)
